# Primjer algoritama za minimalnu zatvorenu šetnju

## Graf od 5 čvorova

```mermaid
graph TD
    A -- 2 --- B
    A -- 3 --- C
    A -- 1 --- D
    B -- 4 --- C
    B -- 5 --- E
    C -- 6 --- D
    C -- 7 --- E
    D -- 8 --- E
```

Težine bridova:
- A-B: 2
- A-C: 3  
- A-D: 1
- B-C: 4
- B-E: 5
- C-D: 6
- C-E: 7
- D-E: 8

## 1. Algoritam preko MST-a (2-aproksimacija)

### Korak 1: Pronađi MST (Primov algoritam)
Počinjemo od čvora A:

```
Korak 0: A (težina 0)
Dodaj A-D (težina 1) - najjeftiniji
Korak 1: A, D
Dodaj A-B (težina 2) - najjeftiniji
Korak 2: A, D, B  
Dodaj B-C (težina 4) - najjeftiniji
Korak 3: A, D, B, C
Dodaj B-E (težina 5) - najjeftiniji
```

**MST:** A-D, A-B, B-C, B-E  
**Ukupna težina MST:** 1 + 2 + 4 + 5 = 12

```mermaid
graph TD
    A -- 2 --- B
    A -- 1 --- D
    B -- 4 --- C
    B -- 5 --- E
```

### Korak 2: Udvostruči bridove MST-a
```mermaid
graph TD
    A -- 2 --- B
    A -- 2 --- B
    A -- 1 --- D
    A -- 1 --- D
    B -- 4 --- C
    B -- 4 --- C
    B -- 5 --- E
    B -- 5 --- E
```

### Korak 3: Eulerov krug
Eulerov krug: A → B → C → B → E → B → A → D → A  
**Dužina:** 2 + 4 + 4 + 5 + 5 + 2 + 1 + 1 = 24

### Korak 4: Skrati put (preskači već posjećene)
A → B → C → E → D → A  
**Dužina:** 2 + 4 + 7 + 8 + 1 = 22

## 2. Christofidesov algoritam (1.5-aproksimacija)

### Korak 1: MST (isti kao gore)
MST: A-D, A-B, B-C, B-E  
Težina: 12

### Korak 2: Pronađi čvorove neparnog stupnja
U MST-u: A, C, D, E (svi imaju neparan stupanj)

### Korak 3: Minimalno savršeno sparivanje
Sparivanja moguća:
- A-C (3) + D-E (8) = 11
- A-D (1) + C-E (7) = 8 ✓
- A-E (nema direktno, treba najkraći put A-B-E = 7) + C-D (6) = 13

**Minimalno sparivanje:** A-D (1), C-E (7) = ukupno 8

### Korak 4: Kombiniraj MST i sparivanje
```mermaid
graph TD
    A -- 2 --- B
    A -- 1 --- D
    B -- 4 --- C
    B -- 5 --- E
    A -- 1 --- D
    C -- 7 --- E
```

### Korak 5: Eulerov krug → Hamiltonov
Eulerov krug: A → B → C → E → B → A → D → A  
**Dužina:** 2 + 4 + 7 + 5 + 2 + 1 + 1 = 22

Skraćivanje: A → B → C → E → D → A  
**Dužina:** 2 + 4 + 7 + 8 + 1 = 22

## Zaključak

Oba algoritma daju isti rezultat za ovaj graf: **A → B → C → E → D → A** sa ukupnom dužinom **22**.

**Optimalno rješenje** (provjera): A → D → E → B → C → A = 1 + 8 + 5 + 4 + 3 = 21  
Christofides je dao bolju aproksimaciju (22 vs optimalno 21).

# Iscrpna pretraga za minimalnu zatvorenu šetnju

## Definicija problema
Minimalna zatvorena šetnju (Travelling Salesman Problem - TSP) traži Hamiltonov ciklus minimalne ukupne težine u grafu.

## Graf od 5 čvorova
```
Težine bridova:
A-B: 2, A-C: 3, A-D: 1, A-E: ∞ (nema direktni brid)
B-C: 4, B-E: 5  
C-D: 6, C-E: 7
D-E: 8
```

## Algoritam iscrpne pretrage

### Pseudokod
```
function EXHAUSTIVE_TSP(graph):
    n = broj čvorova u grafu
    min_cost = ∞
    best_tour = []
    
    // Generiraj sve permutacije čvorova (počevši od fiksnog početnog)
    for each permutacija P od [1, 2, ..., n-1]:
        tour = [0] + P + [0]  // završi u početnom čvoru
        cost = 0
        
        // Izračunaj ukupnu težinu šetnje
        for i = 0 to n-1:
            u = tour[i]
            v = tour[i+1]
            if postoji_brid(u, v):
                cost += težina(u, v)
            else:
                cost = ∞
                break
        
        if cost < min_cost:
            min_cost = cost
            best_tour = tour
    
    return best_tour, min_cost
```

### Implementacija u Pythonu

```python
import itertools

def exhaustive_tsp(graph):
    n = len(graph)
    vertices = list(range(n))
    min_cost = float('inf')
    best_tour = []
    
    # Generiraj sve permutacije (n-1)! jer fiksiramo početni čvor
    for perm in itertools.permutations(vertices[1:]):
        tour = [0] + list(perm) + [0]  # počni i završi u čvoru 0 (A)
        cost = 0
        valid = True
        
        # Provjeri je li šetnja valjana i izračunaj težinu
        for i in range(len(tour)-1):
            u, v = tour[i], tour[i+1]
            if graph[u][v] == float('inf'):
                valid = False
                break
            cost += graph[u][v]
        
        if valid and cost < min_cost:
            min_cost = cost
            best_tour = tour
    
    return best_tour, min_cost

# Reprezentacija grafa
graph = [
    [0, 2, 3, 1, float('inf')],  # A: A,B,C,D,E
    [2, 0, 4, float('inf'), 5],  # B
    [3, 4, 0, 6, 7],             # C
    [1, float('inf'), 6, 0, 8],  # D
    [float('inf'), 5, 7, 8, 0]   # E
]

# Mapiranje indeksa na čvorove
vertex_map = {0: 'A', 1: 'B', 2: 'C', 3: 'D', 4: 'E'}
```

## Analiza svih mogućih šetnji

Broj mogućih šetnji: (5-1)! = 4! = 24

### Sve moguće šetnje (počevši od A):

1. **A-B-C-D-E-A**: 2 + 4 + 6 + 8 + ∞ = ∞ (nema A-E)
2. **A-B-C-E-D-A**: 2 + 4 + 7 + 8 + 1 = 22
3. **A-B-D-C-E-A**: 2 + ∞ + ... = ∞ (nema B-D)
4. **A-B-D-E-C-A**: 2 + ∞ + ... = ∞ (nema B-D)
5. **A-B-E-C-D-A**: 2 + 5 + 7 + 6 + 1 = 21 ✓
6. **A-B-E-D-C-A**: 2 + 5 + 8 + 6 + 3 = 24

7. **A-C-B-D-E-A**: 3 + 4 + ∞ + ... = ∞ (nema B-D)
8. **A-C-B-E-D-A**: 3 + 4 + 5 + 8 + 1 = 21 ✓
9. **A-C-D-B-E-A**: 3 + 6 + ∞ + ... = ∞ (nema D-B)
10. **A-C-D-E-B-A**: 3 + 6 + 8 + 5 + 2 = 24
11. **A-C-E-B-D-A**: 3 + 7 + 5 + ∞ + ... = ∞ (nema B-D)
12. **A-C-E-D-B-A**: 3 + 7 + 8 + ∞ + ... = ∞ (nema D-B)

13. **A-D-B-C-E-A**: 1 + ∞ + ... = ∞ (nema D-B)
14. **A-D-B-E-C-A**: 1 + ∞ + ... = ∞ (nema D-B)
15. **A-D-C-B-E-A**: 1 + 6 + 4 + 5 + ∞ = ∞ (nema E-A)
16. **A-D-C-E-B-A**: 1 + 6 + 7 + 5 + 2 = 21 ✓
17. **A-D-E-B-C-A**: 1 + 8 + 5 + 4 + 3 = 21 ✓
18. **A-D-E-C-B-A**: 1 + 8 + 7 + 4 + 2 = 22

19. **A-E-B-C-D-A**: ∞ + ... = ∞ (nema A-E)
20. **A-E-B-D-C-A**: ∞ + ... = ∞ (nema A-E)
21. **A-E-C-B-D-A**: ∞ + ... = ∞ (nema A-E)
22. **A-E-C-D-B-A**: ∞ + ... = ∞ (nema A-E)
23. **A-E-D-B-C-A**: ∞ + ... = ∞ (nema A-E)
24. **A-E-D-C-B-A**: ∞ + ... = ∞ (nema A-E)

## Rezultati iscrpne pretrage

**Optimalne šetnje (težina 21):**
1. A-B-E-C-D-A: 2 + 5 + 7 + 6 + 1 = 21
2. A-C-B-E-D-A: 3 + 4 + 5 + 8 + 1 = 21  
3. A-D-C-E-B-A: 1 + 6 + 7 + 5 + 2 = 21
4. A-D-E-B-C-A: 1 + 8 + 5 + 4 + 3 = 21

**Suboptimalne šetnje:**
- Težina 22: A-B-C-E-D-A, A-D-E-C-B-A
- Težina 24: A-B-E-D-C-A, A-C-D-E-B-A

## Kompleksnost

- **Vremenska kompleksnost**: O(n!)
- **Prostorna kompleksnost**: O(n)

Za n = 5: 4! = 24 šetnji  
Za n = 10: 9! = 362,880 šetnji  
Za n = 20: 19! ≈ 1.2 × 10¹⁷ šetnji (nepraktično)

## Zaključak

Iscrpna pretraga garantira pronalazak optimalnog rješenja, ali je praktična samo za vrlo male instance problema zbog eksponencijalne kompleksnosti. Za ovaj graf od 5 čvorova, optimalna težina je **21**, što je bolje od rezultata aproksimativnih algoritama (22).